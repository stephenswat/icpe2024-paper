\section{Introduction}

Structured multi-dimensional data are ubiquitous in high-per\-for\-mance computing~\cite{10.1145/1562764.1562783}: three-dimensional fluid simulations, dense linear algebra operations, and stencil kernels are just a few examples of applications which rely fundamentally on multi-dimensional arrays. In spite of the importance of such applications, however, most modern computer systems have one-dimensional memories: from the perspective of the programmer, memory is nothing more than a very large one-dimensional array of bytes. This discrepancy between application requirements and hardware design requires programmers to carefully consider \emph{array layouts}: injective functions which translate multi-dimensional indices into one-dimensional memory addresses.

Although array layouts do not impact the functional properties of programs, choosing a suitable layout can significantly impact application performance in modern processors with complex cache hierarchies~\cite{1214317}. Exploiting these caches is of critical importance to achieving high performance in all but purely compute-bound applications, but doing so requires locality of access---both temporal and spatial---in memory. Kernels often exhibit locality in multiple dimensions, and a well-chosen array layout maximizes the degree to which this application-level locality is translated to the address-level locality that caches are designed to exploit; as a result, that layout increases the efficacy of hardware caching and---by extension---the performance of an application.

Data in two-dimensions is commonly laid out in \emph{row-major} order (shown in \cref{fig:layouts8x8:000111} for an $8 \times 8$ array) or \emph{column-major} order (\cref{fig:layouts8x8:111000}) which provide good locality of access in a single dimension, but poor locality in all others. Thankfully, the design space for data orderings---in two dimensions or more---extends far beyond these canonical layouts: the \emph{Morton} layout (\cref{fig:layouts8x8:010101}), for example, is a layout based on a space-filling curve which provides balanced locality between multiple dimensions~\cite{morton1966computer,10.1002/cpe.1018}. Our work explores a family of data layouts which generalize the Morton order, and allow us to carefully tune the cache behavior in multiple dimensions to match a given application.

The design space of the aforementioned family of data layouts is dauntingly large; indeed, the number of possible layout for arrays at scales applicable to real-world problems is so large that it renders exhaustive search infeasible. In order to find suitable array layouts in tractable amounts of time, we propose to employ genetic algorithms---heuristics known to be able to efficiently find high-quality solutions in large search spaces~\cite{holland1992genetic}. To this end, we design a chromosomal representation of Morton-like array layouts, as well as a fitness function that uses cache simulation to estimate the performance of individual array layouts. Finally, we evaluate our evolutionary strategy and the array layouts it discovers.

In short, our paper makes the following contributions:

\begin{itemize}
    \item We characterize the design space given by a generalization of the Morton array layout, and we show that that the size of this design space renders exhaustive search infeasible (\cref{sec:bijections});
    \item We propose an evolutionary methodology based on genetic algorithms for exploring the aforementioned design space based on the simulated cache-friendliness of layouts (\cref{sec:exploration});
    \item We design and execute a series of experiments to assess the accuracy of our fitness function, the efficacy of our evolutionary process, and the performance of the discovered array layouts, showing that our method can improve performance up to a factor ten (\cref{sec:experiments}).
\end{itemize}
